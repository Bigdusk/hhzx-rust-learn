///变量绑定与结构

#[test]
fn main() {
    //变量可变性
    //test1();

    //使用下划线开头忽略未使用的变量
    //test2();

    //变量解构
    //test3();

    //rust里面的常量 const
    //test4();

    //变量遮蔽
    //test5();
}

fn test5() {
    let a = 1;
    //第二个a变量会将第一个替代掉
    let a = a + 1;
    println!("{}", a);
}

fn test4() {
    /*    变量的值不能更改可能让你想起其他另一个很多语言都有的编程概念：
    常量(constant)。与不可变变量一样，
    常量也是绑定到一个常量名且不允许更改的值，
    但是常量和变量之间存在一些差异：

    常量不允许使用 mut。常量不仅仅默认不可变，而且自始至终不可变，因为常量在编译完成后，已经确定它的值。
    常量使用 const 关键字而不是 let 关键字来声明，并且值的类型必须标注。
    我们将在下一节数据类型中介绍，因此现在暂时无需关心细节。

    下面是一个常量声明的例子，其常量名为 MAX_POINTS，值设置为 100,000。
    Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词，另外对数字字面量可插入下划线以提高可读性*/

    const MAX_POINTS:i32 = 100_000;
    //100_000里面的下划线只为了增加可阅读性
    println!("{}", MAX_POINTS);
}

fn test3() {
    //let 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：
    // 从一个相对复杂的变量中，匹配出该变量的一部分内容：
    let (a, mut b): (bool, bool) = (true, false);
    //a不可变， b可变
    println!("{}{}", a, b)
}

fn test2() {
    //当你未使用变量时会出现报错，可以在前面加上_a解决报错
    let a = 1;
    let _b = 1;
}

fn test1() {
    //变量的可变性
    let a = 1;
    //报错，rust里面默认，变量不可变
    //a = 2;

    //正确示范
    let mut b = 1;
    b = 3;
    println!("{}", b);
}